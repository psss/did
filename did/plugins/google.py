
"""
Google stats such as attended events or completed tasks

Config example::

    [google]
    type = google
    client_id = <client_id>
    client_secret = <client_secret>
    apps = calendar,tasks
    storage = ~/.did/google-api-credentials.json
    skip = ["Lunch break", "Status deadline"]

Make sure you have additional dependencies of the google plugin
installed on your system::

    sudo dnf install python3-google-api-client \
        python3-google-auth \
        python3-google-auth-oauthlib
    pip install did[google]

To retrieve data via Google API, you will need to create access
credentials (``client_id`` and ``client_secret``) first. Perform the
following steps to create such a pair:

    1. Open https://console.developers.google.com/flows/enableapi?apiid=calendar,tasks
    2. You will need to create new project first, select organization
       and location for it
    3. Enable both APIs (tasks and calendar) on the next page after you
       confirm
    4. From the left tab go to 'APIs & Services' and 'OAuth consent
       screen'
    5. In *What data will you be accessing?*, choose *User data*
    6. In there create new and fill at least an app name and emails
    7. On the next page select all scopes or at least all relevant to
       calendar and tasks, you will need to go through all the pages
    8. Save it and go to 'Credentials' tab
    9. Select 'Create credentials' and choose 'OAuth client ID'
    10. Choose app type, doesn't matter but Desktop is likely the
        correct choice and add a name
    11. With that created you will be presented with ``client_id`` and
        ``client_secret`` which you can save into your config file

The ``apps`` configuration option defines the scope of user data the
application will request (read-only) access to. Currently, the only
supported values are ``calendar`` and ``tasks``.

During the first run, user will be asked to grant the plugin access
rights to selected apps. If the user approves the request, this decision
is remembered by creating a *credential storage* file. The path to the
storage can be customized by configuring the ``storage`` option.

If you want to store the ``client_id`` and ``client_secret`` not as
plain text within your config file, use ``client_id_file`` and
``client_secret_file`` to point to files with the corresponding files.
"""  # noqa: W505

import json
import os
from argparse import Namespace
from datetime import datetime
from typing import Any, Optional, cast

from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import Flow  # type: ignore[import-untyped]
from googleapiclient import discovery  # type: ignore[import-untyped]

from did.base import CONFIG, Config, ReportError, User, get_token
from did.stats import Stats, StatsGroup
from did.utils import log, split

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#  Constants
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

DEFAULT_APPS = ["calendar"]

REDIRECT_URI = "urn:ietf:wg:oauth:2.0:oob"

CREDENTIAL_DIR = CONFIG
CREDENTIAL_FILE = "google-api-credentials.json"
CREDENTIAL_PATH = os.path.join(CREDENTIAL_DIR, CREDENTIAL_FILE)

USER_AGENT = "did"


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#  Authorized HTTP session
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def load_credentials_from_file(file_path: str) -> Optional[Credentials]:
    """
    Load credentials from a JSON file.

    Generated by Claude 3.5 Sonnet fixing #415
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            cred_data = json.load(f)

        # Convert token_expiry string to datetime if present
        expiry = None
        if 'token_expiry' in cred_data and cred_data['token_expiry']:
            try:
                # Handle different datetime formats
                if cred_data['token_expiry'].endswith('Z'):
                    expiry = datetime.fromisoformat(cred_data['token_expiry'][:-1])
                else:
                    expiry = datetime.fromisoformat(cred_data['token_expiry'])
            except ValueError:
                # If parsing fails, let expiry remain None
                pass

        return Credentials(  # type: ignore[no-untyped-call]
            token=cred_data.get('access_token'),
            refresh_token=cred_data.get('refresh_token'),
            token_uri=cred_data.get('token_uri'),
            client_id=cred_data.get('client_id'),
            client_secret=cred_data.get('client_secret'),
            scopes=cred_data.get('scopes'),
            expiry=expiry
            )
    except (FileNotFoundError, json.JSONDecodeError, KeyError):
        return None


def save_credentials_to_file(credentials: Credentials, file_path: str) -> None:
    """
    Save credentials to a JSON file.

    Generated by Claude 3.5 Sonnet fixing #415
    """
    cred_data = {
        'access_token': credentials.token,
        'refresh_token': credentials.refresh_token,
        'token_uri': credentials.token_uri,
        'client_id': credentials.client_id,
        'client_secret': credentials.client_secret,
        'scopes': credentials.scopes,
        'token_expiry': credentials.expiry.isoformat() if credentials.expiry else None
        }

    os.makedirs(os.path.dirname(file_path), exist_ok=True)
    with open(file_path, 'w', encoding='utf-8') as f:
        json.dump(cred_data, f, indent=2)


def get_credentials(client_id: str,
                    client_secret: str,
                    apps: list[str],
                    file: Optional[str] = None) -> Credentials:
    """
    Get valid user credentials for Google APIs.

    Try fetching valid user credentials from storage. If nothing has
    been stored, or if the stored credentials are invalid, complete the
    OAuth2 flow to obtain new credentials.

   Generated by Claude 3.5 Sonnet fixing #415
    """
    if not os.path.exists(CREDENTIAL_DIR):
        os.makedirs(CREDENTIAL_DIR)

    credential_path = file or CREDENTIAL_PATH
    credentials = load_credentials_from_file(credential_path)

    scopes = [f"https://www.googleapis.com/auth/{app}.readonly" for app in apps]

    # Check if we need to refresh or obtain new credentials
    if (not credentials or
            not credentials.valid or
            not set(scopes).issubset(set(credentials.scopes or []))):

        # Try to refresh existing credentials first
        if credentials and credentials.refresh_token:
            try:
                request = Request()  # type: ignore[no-untyped-call]
                credentials.refresh(request)
                save_credentials_to_file(credentials, credential_path)
            except Exception:  # pylint: disable=broad-except
                # If refresh fails, we need to re-authorize
                credentials = None

        # If we still don't have valid credentials, start OAuth flow
        if not credentials or not credentials.valid:
            flow = Flow.from_client_config(
                {
                    "installed": {
                        "client_id": client_id,
                        "client_secret": client_secret,
                        "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                        "token_uri": "https://oauth2.googleapis.com/token",
                        "redirect_uris": [REDIRECT_URI]
                        }
                    },
                scopes=scopes
                )
            flow.redirect_uri = REDIRECT_URI

            # Get authorization URL
            auth_url, _ = flow.authorization_url(
                access_type='offline',
                prompt='consent'
                )

            print(f"Please visit this URL to authorize this application: {auth_url}")

            # Get authorization code from user
            auth_code = input("Enter the authorization code: ").strip()

            # Exchange code for credentials
            flow.fetch_token(code=auth_code)
            credentials = flow.credentials

            # Save credentials for future use
            if credentials:
                save_credentials_to_file(credentials, credential_path)

    # Return the credentials object
    if not credentials:
        raise RuntimeError("Failed to obtain valid credentials")
    return credentials


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#  Google Calendar
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

class GoogleCalendar():
    """ Google Calendar functions """
    # pylint: disable=too-few-public-methods

    def __init__(self,
                 http_credentials: tuple[str, str, list[str], Optional[str]],
                 parent: "GoogleStatsGroup") -> None:
        self._credentials = http_credentials
        self.parent = parent

    def events(self, **kwargs: Any) -> list["Event"]:
        """ Fetch events meeting specified criteria """
        if self.parent.options is None:
            raise RuntimeError("GoogleStatsGroup options not set")
        # Get credentials directly instead of session
        credentials = get_credentials(*self._credentials)
        service = discovery.build("calendar", "v3", credentials=credentials)
        # pylint: disable=no-member
        events_result = service.events().list(**kwargs).execute()
        # pylint: enable=no-member
        return [Event(event, self.parent.options.format)
                for event in events_result.get("items", [])]


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#  Event
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

class Event():
    """ Google Calendar Event """
    creator: dict[str, str]
    start: dict[str, Any]
    summary: str

    def __init__(self, in_dict: dict[str, Any], out_format: str):
        """ Create Event object from dict returned by Google API """
        self.__dict__ = in_dict
        self._format = out_format

    def __str__(self) -> str:
        """ String representation """
        # undefined properties are provided via __getitem__
        # pylint: disable=E1101
        if self._format == "markdown":
            date = (
                self.start["date"]
                if "date" in self.start
                else self.start["dateTime"][:10]
                )
            return f"{date} - *{self.summary}*"
        # plain text
        return self.summary

    def __getitem__(self, name: str) -> Any:
        return self.__dict__.get(name, None)

    def created_by(self, email: str) -> bool:
        """ Check if user created the event """
        return str(self.creator["email"]) == email

    def organized_by(self, email: str) -> bool:
        """ Check if user created the event """
        return str(self["organizer"]["email"]) == email

    def attended_by(self, email: str) -> bool:
        """ Check if user attended the event """
        for attendee in self["attendees"] or []:
            if (attendee["email"] == email
                    and attendee["responseStatus"] == "accepted"):
                return True
        return False


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#  Google Tasks
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

class GoogleTasks():
    """ Google Tasks functions """
    # pylint: disable=too-few-public-methods

    def __init__(self,
                 http_credentials: tuple[str, str, list[str], Optional[str]],
                 parent: "GoogleStatsGroup") -> None:
        self._credentials = http_credentials
        self.parent = parent

    def tasks(self, **kwargs: Any) -> list["Task"]:
        """ Fetch tasks specified criteria """
        if self.parent.options is None:
            raise RuntimeError("GoogleStatsGroup options not set")
        # Get credentials directly instead of session
        credentials = get_credentials(*self._credentials)
        service = discovery.build("tasks", "v1", credentials=credentials)
        # pylint: disable=no-member
        tasks_result = service.tasks().list(**kwargs).execute()
        # pylint: enable=no-member
        return [Task(task, self.parent.options.format)
                for task in tasks_result.get("items", [])]


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#  Task
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

class Task():
    """ Google Tasks task """

    def __init__(self, in_dict: dict[str, Any], out_format: str):
        """ Create Task object from dict returned by Google API """
        self.__dict__ = in_dict
        self._format = out_format

    def __str__(self) -> str:
        """ String representation """
        return getattr(self, "title") if hasattr(self, "title") else "(No title)"

    def __getitem__(self, name: str) -> Any:
        return self.__dict__.get(name, None)


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#  Stats
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

class GoogleStatsBase(Stats):
    """ Base class containing common code """

    def __init__(self,
                 option: str,
                 name: Optional[str] = None,
                 parent: Optional["GoogleStatsGroup"] = None) -> None:
        self.parent: GoogleStatsGroup
        self.options: Namespace
        self.user: User
        self.since: Optional[str] = None
        self.until: Optional[str] = None
        super().__init__(option=option, name=name, parent=parent)
        try:
            if self.options is None:
                raise AttributeError("parent not ready yet")
            self.since = f"{self.options.since.datetime.isoformat()}Z"
            self.until = f"{self.options.until.datetime.isoformat()}Z"
        except AttributeError:
            log.debug("Failed to initialize time range, skipping")
        self._events: Optional[list[Event]] = None
        self._tasks: Optional[list[Task]] = None

    @property
    def events(self) -> Optional[list[Event]]:
        """ All events in calendar within specified time range """
        if self._events is None and self.parent is not None:
            log.debug("Fetching calendar events since %s until %s",
                      self.since, self.until)
            self._events = self.parent.calendar.events(
                calendarId="primary", singleEvents=True, orderBy="startTime",
                timeMin=self.since, timeMax=self.until)
            self._events = [event for event in self._events
                            if str(event.summary) not in self.parent.skip]
        return self._events

    @property
    def tasks(self) -> Optional[list[Task]]:
        """ All completed tasks within specified time range """
        if self._tasks is None and self.parent is not None:
            self._tasks = self.parent.tasks.tasks(
                tasklist="@default", showCompleted="true", showHidden="true",
                completedMin=self.since, completedMax=self.until)
        if self._tasks is not None:
            log.info("NB TASKS %s", len(self._tasks))
        return self._tasks

    def fetch(self) -> None:
        """ Fetch the stats (to be implemented by respective class). """
        raise NotImplementedError()


class GoogleEventsOrganized(GoogleStatsBase):
    """ Events organized """

    def fetch(self) -> None:
        if self.events is None:
            raise RuntimeError("GoogleEventsOrganized events not set")
        log.info("Searching for events organized by %s", self.user)
        self.stats = [
            event for event in self.events
            if event.organized_by(self.user.email)
            ]


class GoogleEventsAttended(GoogleStatsBase):
    """ Events attended """

    def fetch(self) -> None:
        if self.events is None:
            raise RuntimeError("GoogleEventsAttended events not set")
        log.info("Searching for events attended by %s", self.user)
        self.stats = [
            event for event in self.events
            if event.attended_by(self.user.email)
            ]


class GoogleTasksCompleted(GoogleStatsBase):
    """ Tasks completed """

    def fetch(self) -> None:
        if self.tasks is None:
            raise RuntimeError("GoogleTasksCompleted tasks not set")
        log.info("Searching for completed tasks by %s", self.user)
        self.stats = self.tasks


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#  Google Stats Group
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

class GoogleStatsGroup(StatsGroup):
    """ Google stats group """

    # Default order
    order = 50

    def __init__(self,
                 option: str,
                 name: Optional[str] = None,
                 parent: Optional[StatsGroup] = None,
                 user: Optional[User] = None) -> None:
        super().__init__(option, name, parent, user)
        config = dict(Config().section(option))
        client_id = get_token(
            config, token_key="client_id", token_file_key="client_id_file")
        if client_id is None:
            raise ReportError("Could not find a client id for Google Calendar")
        client_secret = get_token(
            config,
            token_key="client_secret",
            token_file_key="client_secret_file")
        if client_secret is None:
            raise ReportError("Could not find a client secret for Google Calendar")
        storage = config.get("storage")
        if storage is not None:
            storage = os.path.expanduser(storage)
        try:
            apps = [app.lower() for app in split(config["apps"])]
        except KeyError:
            apps = DEFAULT_APPS
        self.skip: list[str] = cast(list[str], config.get("skip", []))

        http_credentials = (client_id, client_secret, apps, storage)
        self.calendar = GoogleCalendar(http_credentials, self)
        self.tasks = GoogleTasks(http_credentials, self)

        self.stats = [
            GoogleEventsOrganized(
                option=f"{option}-events-organized", parent=self),
            GoogleEventsAttended(
                option=f"{option}-events-attended", parent=self),
            GoogleTasksCompleted(
                option=f"{option}-tasks-completed", parent=self),
            ]
